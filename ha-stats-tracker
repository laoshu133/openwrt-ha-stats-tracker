#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const { exec } = require('child_process');

// Application configuration
const APP_NAME = "HA Stats Tracker";
const VERSION = "1.0.2";

// Log function
function log(message, isDebug = false) {
    if (isDebug && !global.DEBUG) {
        return;
    }
    const LOG_PREFIX = `[${APP_NAME}]`;
    const logPriority = isDebug ? 'debug' : 'info';

    // Use logger command to write to system log
    exec(`logger -t "${LOG_PREFIX}" -p daemon.${logPriority} "${message}"`, (error) => {
        if (error) {
            // If writing to system log fails, fallback to console output
            console[logPriority](`${LOG_PREFIX} ${message}`);
        }
    });
}

// Get device information
function getDeviceInfo() {
    let name = 'openwrt_unknown_device';
    try {
        name = fs.readFileSync('/proc/sys/kernel/hostname', 'utf8').trim();
    }
    catch (error) {}

    return {
        name: name,
        id: name.toLowerCase().replace(/-/g, '_'),
        manufacturer: 'OpenWrt',
        model: 'OpenWrt'
    }
}

// Get system status
async function getSystemStats() {
    const stats = {};

    // Get temperature
    try {
        const temp = await fs.promises.readFile('/sys/class/thermal/thermal_zone0/temp', 'utf8');
        stats.temperature = parseFloat((parseInt(temp) / 1000).toFixed(3));
    } catch (error) {
        // Skip when temperature reading fails
    }

    // Get load
    try {
        const loadAvg = await fs.promises.readFile('/proc/loadavg', 'utf8');
        const [load1min, load5min, load15min] = loadAvg.split(' ');
        stats.load_1min = parseFloat(load1min);
        stats.load_5min = parseFloat(load5min);
        stats.load_15min = parseFloat(load15min);
    } catch (error) {
        // Skip when load reading fails
    }

    // Get CPU usage
    try {
        const cpuUsage = await new Promise((resolve, reject) => {
            exec('top -bn1 | grep "CPU:"', (error, stdout) => {
                if (error) reject(error);
                const usage = stdout.split('CPU:')[1].split('%')[0].trim();
                resolve(parseFloat(usage));
            });
        });
        stats.cpu_usage = cpuUsage;
    } catch (error) {
        // Skip when CPU usage reading fails
    }

    return stats;
}

// Get unit for status metric
function getUnitForStat(statName) {
    const units = {
        temperature: 'Â°C',
        cpu_usage: '%'
    };
    return units[statName] || '';
}

// Get icon for status metric
function getIconForStat(statName) {
    const icons = {
        temperature: 'mdi:thermometer',
        load_1min: 'mdi:chart-line',
        load_5min: 'mdi:chart-line',
        load_15min: 'mdi:chart-line',
        cpu_usage: 'mdi:cpu-64-bit'
    };
    return icons[statName] || 'mdi:eye';
}

// Send data to Home Assistant
async function sendToHA(entityId, data, config) {
    const url = new URL(`${config.hass_url}/api/states/${entityId}`);

    try {
        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${config.hass_token}`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(data)
        });

        if (!response.ok) {
            throw new Error(`HTTP Error: ${response.status}`);
        }

        return true;
    } catch (error) {
        throw error;
    }
}

// Update version entity
async function updateVersionEntity(deviceInfo, config) {
    const entityId = `sensor.${deviceInfo.id}_stats_tracker_version`;
    const data = {
        state: VERSION,
        attributes: {
            friendly_name: `Openwrt(${deviceInfo.name}) Stats Tracker Version`,
            icon: 'mdi:information'
        }
    };

    try {
        await sendToHA(entityId, data, config);
        log('Version entity updated successfully', true);
        return true;
    } catch (error) {
        log('Failed to update version entity');
        return false;
    }
}

// Send system status to Home Assistant
async function sendSystemStats(deviceInfo, stats, config) {
    let hasError = false;

    for (const [statName, value] of Object.entries(stats)) {
        const entityId = `sensor.${deviceInfo.id}_${statName}`;

        // Create more friendly display names
        const statDisplayNames = {
            temperature: 'Temperature',
            load_1min: '1 Minute Load',
            load_5min: '5 Minutes Load',
            load_15min: '15 Minutes Load',
            cpu_usage: 'CPU Usage'
        };

        const displayStatName = statDisplayNames[statName] || statName.replace(/_/g, ' ');
        const friendlyName = `${deviceInfo.name} ${displayStatName}`;

        // Create unique ID
        const uniqueId = `${deviceInfo.id}_${statName}`;

        const data = {
            state: value,
            attributes: {
                unit_of_measurement: getUnitForStat(statName),
                friendly_name: friendlyName,
                icon: getIconForStat(statName),
                unique_id: uniqueId
            }
        };

        try {
            await sendToHA(entityId, data, config);
        } catch (error) {
            hasError = true;
            log(`Failed to send data for ${entityId}`);
        }
    }

    return !hasError;
}

// Main function
async function main() {
    // Read configuration file
    const CONFIG_FILE = path.join(__dirname, 'settings.json');

    let config;
    try {
        const configContent = await fs.promises.readFile(CONFIG_FILE, 'utf8');
        config = JSON.parse(configContent);
        config = {
            hass_url: config.hass_url || 'http://homeassistant.local:8123',
            hass_token: config.hass_token || '',
            update_interval: config.update_interval || 60,
            debug: config.debug || false
        };
    } catch (error) {
        log(`Configuration file not found: ${CONFIG_FILE}`);
        process.exit(1);
    }

    if (!config.hass_token) {
        log('Home Assistant token not configured');
        process.exit(1);
    }

    global.DEBUG = config.debug;

    log(`Starting OpenWRT Stats Tracker v${VERSION}`);

    const deviceInfo = getDeviceInfo();

    // Update version entity
    await updateVersionEntity(deviceInfo, config);

    let lastUpdate = 0;
    let haIsOffline = false;

    // Handle process termination signals
    process.on('SIGTERM', () => {
        log('Stopping...');
        process.exit(0);
    });
    process.on('SIGINT', () => {
        log('Stopping...');
        process.exit(0);
    });

    // Main loop
    while (true) {
        const currentTime = Math.floor(Date.now() / 1000);

        if (currentTime - lastUpdate >= config.update_interval) {
            const stats = await getSystemStats();

            if (await sendSystemStats(deviceInfo.id, stats, config)) {
                if (haIsOffline) {
                    log('Home Assistant is back online');
                    await updateVersionEntity(deviceInfo.id, config);
                    haIsOffline = false;
                }
            } else {
                log('Home Assistant seems to be offline, will retry...');
                haIsOffline = true;
                await new Promise(resolve => setTimeout(resolve, 5000));
                continue;
            }

            lastUpdate = currentTime;
        }

        await new Promise(resolve => setTimeout(resolve, 1000));
    }
}

main().catch(error => {
    log(`Error: ${error.message}`);
    process.exit(1);
});
