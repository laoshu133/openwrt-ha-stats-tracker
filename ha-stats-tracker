#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const { exec } = require('child_process');

// Application configuration
const APP_NAME = "HA Stats Tracker";
const VERSION = "1.1.0";

// Log function
function log(message, isDebug = false) {
    if (isDebug && !global.DEBUG) {
        return;
    }

    const LOG_PREFIX = `[${APP_NAME}]`;
    const logPriority = isDebug ? 'debug' : 'info';

    // Use logger command to write to system log
    exec(`logger -t "${LOG_PREFIX}" -p daemon.${logPriority} "${message}"`, (error) => {
        if (error) {
            // If writing to system log fails, fallback to console output
            console[logPriority](`${LOG_PREFIX} ${message}`);
        }
    });

    // If debug mode, output to console
    if (isDebug) {
        console.debug(`${LOG_PREFIX} ${message}`);
    }
}

// Get device information
function getDeviceInfo() {
    let name = 'openwrt_unknown_device';
    try {
        name = fs.readFileSync('/proc/sys/kernel/hostname', 'utf8').trim();
    }
    catch (error) {}

    return {
        name: name,
        id: name.toLowerCase().replace(/-/g, '_'),
        manufacturer: 'OpenWrt',
        model: 'OpenWrt'
    }
}

// Get system status
async function getSystemStats() {
    const stats = {};

    // Get temperature
    try {
        const temp = await fs.promises.readFile('/sys/class/thermal/thermal_zone0/temp', 'utf8');
        stats.temperature = parseFloat((parseInt(temp) / 1000).toFixed(3));
    } catch (error) {
        // Skip when temperature reading fails
    }

    // Get load
    try {
        const loadAvg = await fs.promises.readFile('/proc/loadavg', 'utf8');
        const [load1min, load5min, load15min] = loadAvg.split(' ');
        stats.load_1min = parseFloat(load1min);
        stats.load_5min = parseFloat(load5min);
        stats.load_15min = parseFloat(load15min);
    } catch (error) {
        // Skip when load reading fails
    }

    // Get CPU usage
    try {
        const cpuUsage = await new Promise((resolve, reject) => {
            exec('top -bn1 | grep "CPU:"', (error, stdout) => {
                if (error) reject(error);
                const usage = stdout.split('CPU:')[1].split('%')[0].trim();
                resolve(parseFloat(usage));
            });
        });
        stats.cpu_usage = cpuUsage;
    } catch (error) {
        // Skip when CPU usage reading fails
    }

    return stats;
}

// Get unit for status metric
function getUnitForStat(statName) {
    const units = {
        temperature: 'Â°C',
        cpu_usage: '%'
    };
    return units[statName] || '';
}

// Get icon for status metric
function getIconForStat(statName) {
    const icons = {
        temperature: 'mdi:thermometer',
        load_1min: 'mdi:chart-line',
        load_5min: 'mdi:chart-line',
        load_15min: 'mdi:chart-line',
        cpu_usage: 'mdi:cpu-64-bit'
    };
    return icons[statName] || 'mdi:eye';
}

// Send data to Home Assistant
async function sendToHA(entityId, data, config) {
    const url = new URL(`${config.hass_url}/api/states/${entityId}`);

    try {
        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${config.hass_token}`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(data)
        });

        if (!response.ok) {
            throw new Error(`HTTP Error: ${response.status}`);
        }

        return true;
    } catch (error) {
        throw error;
    }
}

// Update version entity
async function updateVersionEntity(deviceInfo, config) {
    const entityId = `sensor.${deviceInfo.id}_stats_tracker_version`;
    const data = {
        state: VERSION,
        attributes: {
            friendly_name: `Openwrt(${deviceInfo.name}) Stats Tracker Version`,
            icon: 'mdi:information'
        }
    };

    try {
        await sendToHA(entityId, data, config);
        log('Version entity updated successfully', true);
        return true;
    } catch (error) {
        log('Failed to update version entity');
        return false;
    }
}

// Send system status to Home Assistant
async function sendSystemStats(deviceInfo, stats, config) {
    let hasError = false;

    for (const [statName, value] of Object.entries(stats)) {
        const entityId = `sensor.${deviceInfo.id}_${statName}`;

        // Create more friendly display names
        const statDisplayNames = {
            temperature: 'Temperature',
            load_1min: '1 Minute Load',
            load_5min: '5 Minutes Load',
            load_15min: '15 Minutes Load',
            cpu_usage: 'CPU Usage'
        };

        const uniqueId = `${deviceInfo.id}_${statName}`;
        const displayStatName = statDisplayNames[statName] || statName.replace(/_/g, ' ');

        const data = {
            state: value,
            attributes: {
                unit_of_measurement: getUnitForStat(statName),
                friendly_name: `${deviceInfo.name} ${displayStatName}`,
                icon: getIconForStat(statName),

                // TODO: Doesn't work, HA doesn't recognize it
                unique_id: uniqueId
            }
        };

        try {
            log(`Updating data for ${entityId}`, true);
            await sendToHA(entityId, data, config);
        } catch (error) {
            hasError = true;
            log(`Failed to send data for ${entityId}`);
        }
    }

    return !hasError;
}

// Remove an entity
async function removeEntity(entityId, config) {
    const url = new URL(`${config.hass_url}/api/states/${entityId}`);

    try {
        // First check if entity exists
        const checkResponse = await fetch(url, {
            method: 'DELETE',
            headers: {
                'Authorization': `Bearer ${config.hass_token}`,
                'Content-Type': 'application/json'
            }
        });

        // Skip if entity does not exist
        if (!checkResponse.ok && checkResponse.status !== 404) {
            log(`Failed to delete entity ${entityId}: ${checkResponse.statusText}`);

            throw new Error(`HTTP Error: ${checkResponse.status}`);
        }

        log(`Successfully removed entity: ${entityId}`, true);
        return true;
    } catch (error) {
        log(`Failed to remove entity ${entityId}: ${error.message}`);
        return false;
    }
}

// Remove all entities created by this tracker
async function removeAllEntities(config) {
    log('Starting to remove all entities...');

    let success = true;

    const deviceInfo = getDeviceInfo();
    const stats = await getSystemStats();

    // Remove each entity
    for (const statName of Object.keys(stats)) {
        const entityId = `sensor.${deviceInfo.id}_${statName}`;
        const result = await removeEntity(entityId, config);
        if (!result) {
            success = false;
        }
    }

    if (success) {
        log('All entities have been successfully removed');
    } else {
        log('Some entities could not be removed, check the logs for details');
    }

    return success;
}

// Main function
async function main() {
    // Check for command line arguments
    const args = process.argv.slice(2);
    const command = String(args[0] || '').trim();

    // Read configuration file
    const CONFIG_FILE = path.join(__dirname, 'settings.json');

    let config;
    try {
        const configContent = await fs.promises.readFile(CONFIG_FILE, 'utf8');
        config = JSON.parse(configContent);
        config = {
            hass_url: config.hass_url || 'http://homeassistant.local:8123',
            hass_token: config.hass_token || '',
            update_interval: config.update_interval || 60,
            debug: config.debug || false
        };
    } catch (error) {
        log(`Configuration file not found: ${CONFIG_FILE}`);
        process.exit(1);
    }

    if (!config.hass_token) {
        log('Home Assistant token not configured');
        process.exit(1);
    }

    global.DEBUG = config.debug;

    // Handle commands
    if (command === 'remove_all_entities') {
        log(`Starting Remove All Entities...`);
        await removeAllEntities(config);
        return process.exit(0);
    }
    else if (command === 'version') {
        console.log(`HA Stats Tracker: v${VERSION}`);
        return process.exit(0);
    }
    else if (command === 'help') {
        console.log(`
HA Stats Tracker v${VERSION}

Usage: ha-stats-tracker [command]

Available commands:
  help                 Display this help information
  version              Display version information
  startup              Install and configure boot service
  remove_all_entities  Remove all entities created in Home Assistant

When run without arguments, the program starts in normal mode,
collecting system statistics and sending them to Home Assistant.
        `);
        return process.exit(0);
    }
    else if (command === 'startup') {
        log(`Installing startup service...`, true);

        // Create init.d script content
        const initScript = `#!/bin/sh /etc/rc.common

        START=90
        STOP=1
        PROG=${path.join(__dirname, 'ha-stats-tracker')}

        start_service() {
            procd_open_instance
            procd_set_param command "$PROG"
            procd_set_param stdout 1
            procd_set_param stderr 1
            procd_set_param respawn
            procd_set_param term_timeout 300
            procd_close_instance
        }
        `;

        try {
            // Write the init.d script
            fs.writeFileSync('/etc/init.d/ha-stats-tracker', initScript, {
                mode: 0o755
            });
            log('Init.d script created successfully', true);

            // Enable the service
            exec('/etc/init.d/ha-stats-tracker enable', (error) => {
                if (error) {
                    log(`Failed to enable service: ${error.message}`, true);
                    process.exit(1);
                }

                log('Service enabled successfully, will start on next boot', true);
                process.exit(0);
            });
        } catch (error) {
            log(`Failed to create init.d script: ${error.message}`, true);
            process.exit(1);
        }

        // Restart the service
        log('Restarting service...', true);
        exec('/etc/init.d/ha-stats-tracker restart', (error) => {
            if (error) {
                log(`Failed to restart service: ${error.message}`, true);
                process.exit(1);
            }

            log('Service restarted successfully', true);
            process.exit(0);
        });

        return;
    }

    // Check unknown commands
    if (command !=='') {
        log(`Unknown command: ${command}`);
        return process.exit(1);
    }

    // Normal operation mode
    log(`Starting HA Stats Tracker v${VERSION}`);

    const deviceInfo = getDeviceInfo();

    // Update version entity
    await updateVersionEntity(deviceInfo, config);

    let lastUpdate = 0;
    let haIsOffline = false;

    // Handle process termination signals
    process.on('SIGTERM', () => {
        log('Stopping...');
        process.exit(0);
    });
    process.on('SIGINT', () => {
        log('Stopping...');
        process.exit(0);
    });

    // Main loop
    while (true) {
        const currentTime = Math.floor(Date.now() / 1000);

        if (currentTime - lastUpdate >= config.update_interval) {
            const stats = await getSystemStats();

            if (await sendSystemStats(deviceInfo, stats, config)) {
                if (haIsOffline) {
                    log('Home Assistant is back online');
                    await updateVersionEntity(deviceInfo.id, config);
                    haIsOffline = false;
                }
            } else {
                log('Home Assistant seems to be offline, will retry...');
                haIsOffline = true;
                await new Promise(resolve => setTimeout(resolve, 5000));
                continue;
            }

            lastUpdate = currentTime;
        }

        await new Promise(resolve => setTimeout(resolve, 1000));
    }
}

main().catch(error => {
    log(`Error: ${error.message}`);
    process.exit(1);
});
